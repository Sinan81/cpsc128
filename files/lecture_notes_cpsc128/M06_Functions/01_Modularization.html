<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
<title>
Modularization</title>
  <script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.4/jquery.min.js"></script>

  <link rel="Contents" href="../index.html" />
  <link rel="Prev" href="../M05_ListsAndStrings/99_M05_Assignment.html" />
  <link rel="Next" href="02_Functions.html" />
  <link rel="stylesheet" type="text/css" href="../lib/CPSC128F13.css" />
  <script type="text/javascript" src="../lib/build_nav.js"></script>
  <script type="text/javascript" src="../lib/ie_patches.js"></script>
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-193420-1']);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
</head>

<body>
  <header>
  </header>

  <nav>
  </nav>

  <section>
<h1>Modularization</h1>
<p>The first module in this course introduced the six essential imperative
programming operations. There were three simple statements,</p>
<dl>
  <dt><i>input</i> </dt>
    <dd>gets a value from the input stream and stores it in memory. </dd>
  <dt><i>processing</i> </dt>
    <dd>processes/combines/manipulates values stored in memory and stores the
      result in memory </dd>
  <dt><i>output</i> </dt>
    <dd>sends a value to the output stream </dd>
</dl>
<p>and three control structures,</p>
<dl>
  <dt><i>sequential processing</i> </dt>
    <dd>in which statements are executed one at a time in sequence </dd>
  <dt><i>selection</i> </dt>
    <dd>in which one group of statements or another, but not both, are
      executed </dd>
  <dt><i>repetition</i> </dt>
    <dd>in which a group of statements is executed repeatedly </dd>
</dl>
<p>I also introduced one "bonus" structure: modularity. Many modern computer
scientists would take issue with the <em>bonus</em> characterization and
argue that modularization is perhaps the most fundamental structure provided
by modern programming languages.</p>
<p>I do not disagree with their assessment. I refer to the other control
structures as <em>essential</em> because it is logically impossible to write
all programs without each and every one of them. It is possible to write a
program without modularization, but extremely difficult, and the resulting
program if it was ever successfully written and tested would be very
difficult to modify or maintain.</p>
<p>Why is modularization so important? Because it enables us to</p>
<ol>
  <li><strong>reduce the complexity</strong> of our programs, while at the
    same time allowing us to</li>
  <li><strong>create reusable fragments of code</strong>.</li>
</ol>
<p> We reduce complexity by using a divide and conquer strategy, i.e.
taking a large program and dividing it into smaller, more manageable, pieces.
If we choose our pieces carefully, we can accumulate a collection of modules
that are reusable. This saves us time on future projects by allowing us to
avoid reinventing the wheel.</p>
<p>Reducing complexity is important because there is a (small) limit to the
number of things the human brain can think about at once. Cognitive
psychologists often peg the capacity of short term memory at 7 plus or minus
two items, because people can on average only recall between 5 and 9 items
from a sequence they are given to remember. This biological limitation makes
it very difficult to think about problems involving a dozen units, much less
ones involving hundreds of disparate parts. One way of organizing the
complexity of a large system is to divide it into hierarchies that only have a handful of items on any
given level. This division is modularization.
Dividing a problem well, i.e. in a way that makes the problem simpler to
solve, is a skill that is developed through practice and by studying
examples.</p>
<p>As we tackle different programming problems and projects we will build up
a storehouse of modules. If we modularize our problems well we will develop a
toolkit of reusable modules that we can use in the future to avoid rewriting
code we have written before. Choosing modules for reusability is more
objective than choosing them to reduce complexity: the main rule is to make
each module do one thing, and only one thing, well, and to avoid side
effects. We avoid side effects by having each module restrict its actions to
as narrow a domain as possible.</p>
<p>Python enables modularization through the use of </p>
<ol>
  <li><strong>functions</strong>,</li>
  <li><strong>classes</strong>, and</li>
  <li><strong>modules</strong>.</li>
</ol>
<p>In this module of the course we will consider the first and third of
these, i.e. functions and modules. The second item, classes, is the subject of the
entire third part of the course.</p>
  </section>

    <footer>
  This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/">Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License</a>.

  </footer>
</body>
</html>
