<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
<title>
Playing Card Classes: Invisible method</title>
  <script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.4/jquery.min.js"></script>

  <link rel="Contents" href="../index.html" />
  <link rel="Prev" href="23_PCC_Skeleton_1.html" />
  <link rel="Next" href="25_PCC_Skeleton_2.html" />
  <link rel="stylesheet" type="text/css" href="../lib/CPSC128F13.css" />
  <script type="text/javascript" src="../lib/build_nav.js"></script>
  <script type="text/javascript" src="../lib/ie_patches.js"></script>
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-193420-1']);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
</head>

<body>
  <header>
  </header>

  <nav>
  </nav>

  <section>
<h1>An invisible method! (A polymorphic aside)</h1>
<p>Our code in <code>playing_cards_1.py</code> is even runnable. Although it
doesn't do much the output is instructive:</p>
<pre>&gt;&gt;&gt; 
d after shuffling = &lt;__main__.Deck instance at 0x00C65670&gt;
d has None cards
Your hand of None cards contains: &lt;__main__.Hand instance at 0x00C65918&gt;
Your hand of None cards contains: &lt;__main__.Hand instance at 0x00C65828&gt;
There are None cards left in the deck.
&gt;&gt;&gt; </pre>
<p>One thing to note is that functions without an explicit
<code>return</code> statement, like all of ours here, return the special value
<code>None</code>.</p>
<p>The more striking thing though is probably those inscrutable strings
<code>&lt;__main__.Deck instance at 0x00C65670&gt;</code> and
<code>&lt;__main__.Hand instance at 0x00C65918&gt;</code>. You can tell by
where they appear that they are generated by the <code>print</code>
statements. Since print doesn't know how to output <code>Deck</code> and
<code>Hand</code> objects it tells us what it can which is the type and
memory location of the object it has been asked to print.</p>
<p>We can help <code>print</code> out by providing methods that return string
representations of our <code>Deck</code> and <code>Hand</code> objects. By
convention these methods are called <code>__str__</code>. When
<code>print</code> is called and passed an object name it checks the object's
class definition for an <code>__str__</code> method and if one is defined it
calls it and displays the output the method returns. If no
<code>__str__</code> method is found it displays all it can, i.e. the object
type and location as it did above.</p>
<p>This nicely illustrates the simple sleight of hand that lies behind
polymorphism. Until now it seemed that <code>print</code> knew how to print
everything, but in fact it knows very little and just delegates the job to
each class' <code>__str__</code> method while giving the impression that it
is masterful.</p>
<p></p>
  </section>

    <footer>
  This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/">Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License</a>.

  </footer>
</body>
</html>
