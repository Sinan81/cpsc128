<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
<title>
Object-based programming</title>
  <script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.4/jquery.min.js"></script>

  <link rel="Contents" href="../index.html" />
  <link rel="Prev" href="../M04_Repetition/M04_Assignment.html" />
  <link rel="Next" href="02_SequenceTypes.html" />
  
  <link href="../lib/CPSC128F13.css" rel="stylesheet" type="text/css" />
  <script type="text/javascript" src="../lib/build_nav.js"></script>
  <script type="text/javascript" src="../lib/ie_patches.js"></script>
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-193420-1']);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
</head>

<body>
  <header>
  </header>

  <nav>
  </nav>

  <section>
<h1>Object-based programming</h1>
<p>All the values we have worked with in Python have been objects, but we
haven't really been aware of that because we've been able to work with them
using built-in operators. For example we have been able to write <code>x = a + 10</code>
and it has looked enough like regular arithmetic that we haven't had to
address the fact that those things, <code>x</code> and <code>a</code>, are objects.</p>
<p><em>Aside 1</em>: Already though we have seen that the meaning of the
operator depends on the types of the objects to which it is applied. The
<code>+</code> in <code>3 + 2</code> means <em>arithmetic addition</em>, but the <code>+</code> in <code>"Tim" + "Topper"</code> means <em>string concatenation</em>.
Similarly the <code>%</code> in <code>9%5</code> means <em>modulo</em>, but the second <code>%</code> in <code>"%1.2f" % temp</code> means <em>string interpolation</em>.
(Jargon alert: In object oriented programming this is referred to as <em>polymorphism</em> or more specifically <em>operator overloading</em>).</p>
<p><em>Aside 2</em>: Remember that you can query the type of a literal value
or of the value associated with a name by using the built-in function
<code>type</code>, e.g.</p>
<pre><code>&gt;&gt;&gt; type(4)
&lt;type 'int'&gt;
&gt;&gt;&gt; type("Tim")
&lt;type 'str'&gt;
&gt;&gt;&gt; x = 4.5
&gt;&gt;&gt; type(x)
&lt;type 'float'&gt;
&gt;&gt;&gt; last_name = "Topper"
&gt;&gt;&gt; type(last_name)
&lt;type 'str'&gt;
&gt;&gt;&gt; </code></pre>
<p>where <code>int</code> is short for integer, <code>float</code> is short
for floating point and <code>str</code> is short for string.</p>
<p>However, most object types provide more operations than there are built-in
operators. In these cases we use a different notation to specify the
operation to be performed. But to describe that notation it will help to have
a little more jargon.</p>
<p>An <em>object</em> consists of a set of <em>attributes</em> and a set of
<em>methods</em> it knows how to apply to itself. For example we can see that
the string <code>last_name</code> above has as its attribute the sequence of
characters <code>T o p p e r</code>, but what about its methods? One way to
find an object's methods is to use the <code>dir()</code> command, e.g.</p>
<pre><code>&gt;&gt;&gt; dir(last_name)
['__add__', '__class__', '__contains__', '__delattr__', '__doc__', '__eq__', '__ge__', '__getattribute__', '__getitem__', '__getnewargs__', '__getslice__', '__gt__', '__hash__', '__init__', '__le__', '__len__', '__lt__', '__mod__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__rmod__', '__rmul__', '__setattr__', '__str__', 'capitalize', 'center', 'count', 'decode', 'encode', 'endswith', 'expandtabs', 'find', 'index', 'isalnum', 'isalpha', 'isdigit', 'islower', 'isspace', 'istitle', 'isupper', 'join', 'ljust', 'lower', 'lstrip', 'replace', 'rfind', 'rindex', 'rjust', 'rsplit', 'rstrip', 'split', 'splitlines', 'startswith', 'strip', 'swapcase', 'title', 'translate', 'upper', 'zfill']
&gt;&gt;&gt; </code></pre>
<p>The names beginning with double underscores (<code>__</code>) correspond
to the methods invoked by operators, e.g. the <code>__add__</code> method is
invoked when <code>+</code> appears between two string values. The names
after the double underscore names are invoked by giving the name of the
object followed by a period and then the name of the method followed by
parentheses, e.g.</p>
<pre><code>&gt;&gt;&gt; last_name.upper()
'TOPPER'
&gt;&gt;&gt; last_name.center(20)
'       Topper       '
&gt;&gt;&gt;</code></pre>
<p>Note that when the method requires parameters they are listed in the
parentheses, like 20 in the second command above.</p>
<p><em>In Python everything is an object.</em> For instance we have seen this
dot notation before, when importing the modules <code>random</code> and
<code>math</code>. That's because an imported module is an object and we
access the methods the module provides using this same dot notation. The dot
notation for accessing object attributes and methods is common to most
object-oriented languages including C++, Java, and Javascript.</p>
<p>The general syntax to invoke one of an object's methods is,</p>
<pre><code><em>object_name</em>.<em>method_name</em>(<em>parameters</em>)</code></pre>
<p>where the parameters depend on the method, and may  be optional as
in <code>last_name.upper()</code> above, or provided as in <code>last_name.center(20)</code>.</p>
<h2>Jargon summary</h2>
<p class="img"><img alt="." src="01_object_method_param.gif" width="300" height="102" /></p>
  </section>

    <footer>
  This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/">Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License</a>.

  </footer>
</body>
</html>
